Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BEGIN
    BOOL
    COL
    CONST
    CTE_B
    CTE_S
    DETERMATRIZ
    DO
    DOT
    ELIF
    END
    EOF
    FUNCTION
    GLOBAL
    INPUT
    INVERMATRIZ
    LET
    LOCAL
    NOT
    OR
    PRINT
    RETURN
    SELECT
    SWITCH
    THEN
    TRANSMATRIZ
    WHILE

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM ID SEMICOL programa1
Rule 2     programa1 -> vars funcion main funcion
Rule 3     programa1 -> funcion main funcion
Rule 4     programa1 -> funcion main
Rule 5     programa1 -> vars funcion main
Rule 6     programa1 -> vars funcion
Rule 7     programa1 -> vars main
Rule 8     programa1 -> vars main funcion
Rule 9     programa1 -> funcion
Rule 10    programa1 -> vars
Rule 11    programa1 -> main
Rule 12    programa1 -> empty
Rule 13    main -> tipo MAIN LP RP LB statement RB
Rule 14    main -> VOID tipo MAIN LP RP LB statement RB
Rule 15    statement -> asignacion SEMICOL statement
Rule 16    statement -> if statement
Rule 17    statement -> vars statement
Rule 18    statement -> empty
Rule 19    asignacion -> ID IS value
Rule 20    vars -> VAR tipo vars1
Rule 21    vars -> VAR tipo vars2
Rule 22    vars -> VAR tipo vars3
Rule 23    vars -> VAR tipo oper_aritmetica
Rule 24    vars -> varsG
Rule 25    vars -> empty
Rule 26    vars1 -> ID SEMICOL
Rule 27    vars1 -> ID SEMICOL vars
Rule 28    vars2 -> ID IS value COMMA vars2
Rule 29    vars2 -> ID IS value COMMA
Rule 30    vars2 -> ID IS value SEMICOL vars
Rule 31    vars3 -> ID COMMA vars3
Rule 32    vars3 -> ID SEMICOL vars
Rule 33    vars3 -> ID SEMICOL
Rule 34    varsG -> VAR tipo vars1G
Rule 35    varsG -> VAR tipo vars2G
Rule 36    varsG -> VAR tipo vars3G
Rule 37    varsG -> VAR LB varsG RB
Rule 38    vars1G -> ID SEMICOL
Rule 39    vars1G -> ID SEMICOL varsG
Rule 40    vars2G -> ID IS value check_type COMMA vars2G
Rule 41    vars2G -> ID IS value check_type SEMICOL varsG
Rule 42    vars2G -> empty
Rule 43    vars3G -> ID COMMA vars3G
Rule 44    vars3G -> ID SEMICOL varsG
Rule 45    vars3G -> ID SEMICOL
Rule 46    tipo -> INT
Rule 47    tipo -> FLOAT
Rule 48    tipo -> CHAR
Rule 49    value -> CTE_F
Rule 50    value -> CTE_I
Rule 51    value -> ID
Rule 52    value -> CTE_C
Rule 53    value -> COMILLA ID COMILLA
Rule 54    value -> COMILLAS ID COMILLAS
Rule 55    check_type -> <empty>
Rule 56    funcion -> VOID ID LP param RP LB statement RB funcion
Rule 57    funcion -> tipo ID LP param RP LB statement RB funcion
Rule 58    funcion -> VOID ID LP param RP LB statement RB
Rule 59    funcion -> tipo ID LP param RP LB statement RB
Rule 60    param -> <empty>
Rule 61    var_lt -> expr LT expr
Rule 62    var_gt -> expr GT expr
Rule 63    var_leq -> expr LEQ expr
Rule 64    var_geq -> expr GEQ expr
Rule 65    var_equal -> expr EQUAL expr
Rule 66    var_neq -> expr NEQ expr
Rule 67    oper_aritmetica -> ID IS expr SEMICOL
Rule 68    expr -> expr MUL expr
Rule 69    expr -> expr DIV expr
Rule 70    expr -> expr PLUS expr
Rule 71    expr -> expr MINUS expr
Rule 72    expr -> CTE_I
Rule 73    expr -> CTE_F
Rule 74    expr -> ID
Rule 75    expr -> ID row
Rule 76    expr -> ID matrix
Rule 77    row -> LC expr RC
Rule 78    matrix -> row row
Rule 79    empty -> <empty>
Rule 80    if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto
Rule 81    if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
Rule 82    if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto else
Rule 83    elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto
Rule 84    elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif
Rule 85    elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto else
Rule 86    else -> ELSE LB statement RB guarda_salto
Rule 87    expression -> var_gt
Rule 88    expression -> var_lt
Rule 89    expression -> var_equal
Rule 90    expression -> var_neq
Rule 91    expression -> var_geq
Rule 92    expression -> var_leq
Rule 93    expression -> expr
Rule 94    expression -> TRUE
Rule 95    expression -> FALSE
Rule 96    expression -> ID
Rule 97    check_bool -> <empty>
Rule 98    gotof -> <empty>
Rule 99    guarda_salto -> <empty>

Terminals, with rules where they appear

AND                  : 
BEGIN                : 
BOOL                 : 
CHAR                 : 48
COL                  : 
COMILLA              : 53 53
COMILLAS             : 54 54
COMMA                : 28 29 31 40 43
CONST                : 
CTE_B                : 
CTE_C                : 52
CTE_F                : 49 73
CTE_I                : 50 72
CTE_S                : 
DETERMATRIZ          : 
DIV                  : 69
DO                   : 
DOT                  : 
ELIF                 : 
ELSE                 : 86
ELSEIF               : 83 84 85
END                  : 
EOF                  : 
EQUAL                : 65
FALSE                : 95
FLOAT                : 47
FUNCTION             : 
GEQ                  : 64
GLOBAL               : 
GT                   : 62
ID                   : 1 19 26 27 28 29 30 31 32 33 38 39 40 41 43 44 45 51 53 54 56 57 58 59 67 74 75 76 96
IF                   : 80 81 82
INPUT                : 
INT                  : 46
INVERMATRIZ          : 
IS                   : 19 28 29 30 40 41 67
LB                   : 13 14 37 56 57 58 59 80 81 82 83 84 85 86
LC                   : 77
LEQ                  : 63
LET                  : 
LOCAL                : 
LP                   : 13 14 56 57 58 59 80 81 82 83 84 85
LT                   : 61
MAIN                 : 13 14
MINUS                : 71
MUL                  : 68
NEQ                  : 66
NOT                  : 
OR                   : 
PLUS                 : 70
PRINT                : 
PROGRAM              : 1
RB                   : 13 14 37 56 57 58 59 80 81 82 83 84 85 86
RC                   : 77
RETURN               : 
RP                   : 13 14 56 57 58 59 80 81 82 83 84 85
SELECT               : 
SEMICOL              : 1 15 26 27 30 32 33 38 39 41 44 45 67
SWITCH               : 
THEN                 : 
TRANSMATRIZ          : 
TRUE                 : 94
VAR                  : 20 21 22 23 34 35 36 37
VOID                 : 14 56 58
WHILE                : 
error                : 

Nonterminals, with rules where they appear

asignacion           : 15
check_bool           : 80 81 82 83 84 85
check_type           : 40 41
else                 : 82 85
elseif               : 81 84
empty                : 12 18 25 42
expr                 : 61 61 62 62 63 63 64 64 65 65 66 66 67 68 68 69 69 70 70 71 71 77 93
expression           : 80 81 82 83 84 85
funcion              : 2 2 3 3 4 5 6 8 9 56 57
gotof                : 80 81 82
guarda_salto         : 80 81 82 83 84 85 86
if                   : 16
main                 : 2 3 4 5 7 8 11
matrix               : 76
oper_aritmetica      : 23
param                : 56 57 58 59
programa             : 0
programa1            : 1
row                  : 75 78 78
statement            : 13 14 15 16 17 56 57 58 59 80 81 82 83 84 85 86
tipo                 : 13 14 20 21 22 23 34 35 36 57 59
value                : 19 28 29 30 40 41
var_equal            : 89
var_geq              : 91
var_gt               : 87
var_leq              : 92
var_lt               : 88
var_neq              : 90
vars                 : 2 5 6 7 8 10 17 27 30 32
vars1                : 20
vars1G               : 34
vars2                : 21 28
vars2G               : 35 40
vars3                : 22 31
vars3G               : 36 43
varsG                : 24 37 39 41 44

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM ID SEMICOL programa1

    PROGRAM         shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> PROGRAM . ID SEMICOL programa1

    ID              shift and go to state 3


state 3

    (1) programa -> PROGRAM ID . SEMICOL programa1

    SEMICOL         shift and go to state 4


state 4

    (1) programa -> PROGRAM ID SEMICOL . programa1
    (2) programa1 -> . vars funcion main funcion
    (3) programa1 -> . funcion main funcion
    (4) programa1 -> . funcion main
    (5) programa1 -> . vars funcion main
    (6) programa1 -> . vars funcion
    (7) programa1 -> . vars main
    (8) programa1 -> . vars main funcion
    (9) programa1 -> . funcion
    (10) programa1 -> . vars
    (11) programa1 -> . main
    (12) programa1 -> . empty
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (13) main -> . tipo MAIN LP RP LB statement RB
    (14) main -> . VOID tipo MAIN LP RP LB statement RB
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VAR             shift and go to state 10
    VOID            shift and go to state 13
    $end            reduce using rule 79 (empty -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! VOID            [ reduce using rule 79 (empty -> .) ]
  ! INT             [ reduce using rule 79 (empty -> .) ]
  ! FLOAT           [ reduce using rule 79 (empty -> .) ]
  ! CHAR            [ reduce using rule 79 (empty -> .) ]

    programa1                      shift and go to state 5
    vars                           shift and go to state 6
    funcion                        shift and go to state 7
    main                           shift and go to state 8
    empty                          shift and go to state 9
    tipo                           shift and go to state 11
    varsG                          shift and go to state 12

state 5

    (1) programa -> PROGRAM ID SEMICOL programa1 .

    $end            reduce using rule 1 (programa -> PROGRAM ID SEMICOL programa1 .)


state 6

    (2) programa1 -> vars . funcion main funcion
    (5) programa1 -> vars . funcion main
    (6) programa1 -> vars . funcion
    (7) programa1 -> vars . main
    (8) programa1 -> vars . main funcion
    (10) programa1 -> vars .
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (13) main -> . tipo MAIN LP RP LB statement RB
    (14) main -> . VOID tipo MAIN LP RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    $end            reduce using rule 10 (programa1 -> vars .)
    VOID            shift and go to state 13
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    funcion                        shift and go to state 17
    main                           shift and go to state 18
    tipo                           shift and go to state 11

state 7

    (3) programa1 -> funcion . main funcion
    (4) programa1 -> funcion . main
    (9) programa1 -> funcion .
    (13) main -> . tipo MAIN LP RP LB statement RB
    (14) main -> . VOID tipo MAIN LP RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    $end            reduce using rule 9 (programa1 -> funcion .)
    VOID            shift and go to state 21
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    main                           shift and go to state 19
    tipo                           shift and go to state 20

state 8

    (11) programa1 -> main .

    $end            reduce using rule 11 (programa1 -> main .)


state 9

    (12) programa1 -> empty .
    (25) vars -> empty .

  ! reduce/reduce conflict for $end resolved using rule 12 (programa1 -> empty .)
    $end            reduce using rule 12 (programa1 -> empty .)
    VOID            reduce using rule 25 (vars -> empty .)
    INT             reduce using rule 25 (vars -> empty .)
    FLOAT           reduce using rule 25 (vars -> empty .)
    CHAR            reduce using rule 25 (vars -> empty .)

  ! $end            [ reduce using rule 25 (vars -> empty .) ]


state 10

    (20) vars -> VAR . tipo vars1
    (21) vars -> VAR . tipo vars2
    (22) vars -> VAR . tipo vars3
    (23) vars -> VAR . tipo oper_aritmetica
    (34) varsG -> VAR . tipo vars1G
    (35) varsG -> VAR . tipo vars2G
    (36) varsG -> VAR . tipo vars3G
    (37) varsG -> VAR . LB varsG RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    LB              shift and go to state 23
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    tipo                           shift and go to state 22

state 11

    (57) funcion -> tipo . ID LP param RP LB statement RB funcion
    (59) funcion -> tipo . ID LP param RP LB statement RB
    (13) main -> tipo . MAIN LP RP LB statement RB

    ID              shift and go to state 24
    MAIN            shift and go to state 25


state 12

    (24) vars -> varsG .

    VOID            reduce using rule 24 (vars -> varsG .)
    INT             reduce using rule 24 (vars -> varsG .)
    FLOAT           reduce using rule 24 (vars -> varsG .)
    CHAR            reduce using rule 24 (vars -> varsG .)
    $end            reduce using rule 24 (vars -> varsG .)
    ID              reduce using rule 24 (vars -> varsG .)
    IF              reduce using rule 24 (vars -> varsG .)
    VAR             reduce using rule 24 (vars -> varsG .)
    RB              reduce using rule 24 (vars -> varsG .)


state 13

    (56) funcion -> VOID . ID LP param RP LB statement RB funcion
    (58) funcion -> VOID . ID LP param RP LB statement RB
    (14) main -> VOID . tipo MAIN LP RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    ID              shift and go to state 26
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    tipo                           shift and go to state 27

state 14

    (46) tipo -> INT .

    ID              reduce using rule 46 (tipo -> INT .)
    MAIN            reduce using rule 46 (tipo -> INT .)
    VOID            reduce using rule 46 (tipo -> INT .)
    INT             reduce using rule 46 (tipo -> INT .)
    FLOAT           reduce using rule 46 (tipo -> INT .)
    CHAR            reduce using rule 46 (tipo -> INT .)
    $end            reduce using rule 46 (tipo -> INT .)
    IF              reduce using rule 46 (tipo -> INT .)
    VAR             reduce using rule 46 (tipo -> INT .)
    RB              reduce using rule 46 (tipo -> INT .)


state 15

    (47) tipo -> FLOAT .

    ID              reduce using rule 47 (tipo -> FLOAT .)
    MAIN            reduce using rule 47 (tipo -> FLOAT .)
    VOID            reduce using rule 47 (tipo -> FLOAT .)
    INT             reduce using rule 47 (tipo -> FLOAT .)
    FLOAT           reduce using rule 47 (tipo -> FLOAT .)
    CHAR            reduce using rule 47 (tipo -> FLOAT .)
    $end            reduce using rule 47 (tipo -> FLOAT .)
    IF              reduce using rule 47 (tipo -> FLOAT .)
    VAR             reduce using rule 47 (tipo -> FLOAT .)
    RB              reduce using rule 47 (tipo -> FLOAT .)


state 16

    (48) tipo -> CHAR .

    ID              reduce using rule 48 (tipo -> CHAR .)
    MAIN            reduce using rule 48 (tipo -> CHAR .)
    VOID            reduce using rule 48 (tipo -> CHAR .)
    INT             reduce using rule 48 (tipo -> CHAR .)
    FLOAT           reduce using rule 48 (tipo -> CHAR .)
    CHAR            reduce using rule 48 (tipo -> CHAR .)
    $end            reduce using rule 48 (tipo -> CHAR .)
    IF              reduce using rule 48 (tipo -> CHAR .)
    VAR             reduce using rule 48 (tipo -> CHAR .)
    RB              reduce using rule 48 (tipo -> CHAR .)


state 17

    (2) programa1 -> vars funcion . main funcion
    (5) programa1 -> vars funcion . main
    (6) programa1 -> vars funcion .
    (13) main -> . tipo MAIN LP RP LB statement RB
    (14) main -> . VOID tipo MAIN LP RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    $end            reduce using rule 6 (programa1 -> vars funcion .)
    VOID            shift and go to state 21
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    main                           shift and go to state 28
    tipo                           shift and go to state 20

state 18

    (7) programa1 -> vars main .
    (8) programa1 -> vars main . funcion
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    $end            reduce using rule 7 (programa1 -> vars main .)
    VOID            shift and go to state 30
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    funcion                        shift and go to state 29
    tipo                           shift and go to state 31

state 19

    (3) programa1 -> funcion main . funcion
    (4) programa1 -> funcion main .
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    $end            reduce using rule 4 (programa1 -> funcion main .)
    VOID            shift and go to state 30
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    funcion                        shift and go to state 32
    tipo                           shift and go to state 31

state 20

    (13) main -> tipo . MAIN LP RP LB statement RB

    MAIN            shift and go to state 25


state 21

    (14) main -> VOID . tipo MAIN LP RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    tipo                           shift and go to state 27

state 22

    (20) vars -> VAR tipo . vars1
    (21) vars -> VAR tipo . vars2
    (22) vars -> VAR tipo . vars3
    (23) vars -> VAR tipo . oper_aritmetica
    (34) varsG -> VAR tipo . vars1G
    (35) varsG -> VAR tipo . vars2G
    (36) varsG -> VAR tipo . vars3G
    (26) vars1 -> . ID SEMICOL
    (27) vars1 -> . ID SEMICOL vars
    (28) vars2 -> . ID IS value COMMA vars2
    (29) vars2 -> . ID IS value COMMA
    (30) vars2 -> . ID IS value SEMICOL vars
    (31) vars3 -> . ID COMMA vars3
    (32) vars3 -> . ID SEMICOL vars
    (33) vars3 -> . ID SEMICOL
    (67) oper_aritmetica -> . ID IS expr SEMICOL
    (38) vars1G -> . ID SEMICOL
    (39) vars1G -> . ID SEMICOL varsG
    (40) vars2G -> . ID IS value check_type COMMA vars2G
    (41) vars2G -> . ID IS value check_type SEMICOL varsG
    (42) vars2G -> . empty
    (43) vars3G -> . ID COMMA vars3G
    (44) vars3G -> . ID SEMICOL varsG
    (45) vars3G -> . ID SEMICOL
    (79) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 40
    VOID            reduce using rule 79 (empty -> .)
    INT             reduce using rule 79 (empty -> .)
    FLOAT           reduce using rule 79 (empty -> .)
    CHAR            reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    VAR             reduce using rule 79 (empty -> .)
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]

    vars1                          shift and go to state 33
    vars2                          shift and go to state 34
    vars3                          shift and go to state 35
    oper_aritmetica                shift and go to state 36
    vars1G                         shift and go to state 37
    vars2G                         shift and go to state 38
    vars3G                         shift and go to state 39
    empty                          shift and go to state 41

state 23

    (37) varsG -> VAR LB . varsG RB
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

    VAR             shift and go to state 42

    varsG                          shift and go to state 43

state 24

    (57) funcion -> tipo ID . LP param RP LB statement RB funcion
    (59) funcion -> tipo ID . LP param RP LB statement RB

    LP              shift and go to state 44


state 25

    (13) main -> tipo MAIN . LP RP LB statement RB

    LP              shift and go to state 45


state 26

    (56) funcion -> VOID ID . LP param RP LB statement RB funcion
    (58) funcion -> VOID ID . LP param RP LB statement RB

    LP              shift and go to state 46


state 27

    (14) main -> VOID tipo . MAIN LP RP LB statement RB

    MAIN            shift and go to state 47


state 28

    (2) programa1 -> vars funcion main . funcion
    (5) programa1 -> vars funcion main .
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    $end            reduce using rule 5 (programa1 -> vars funcion main .)
    VOID            shift and go to state 30
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    funcion                        shift and go to state 48
    tipo                           shift and go to state 31

state 29

    (8) programa1 -> vars main funcion .

    $end            reduce using rule 8 (programa1 -> vars main funcion .)


state 30

    (56) funcion -> VOID . ID LP param RP LB statement RB funcion
    (58) funcion -> VOID . ID LP param RP LB statement RB

    ID              shift and go to state 26


state 31

    (57) funcion -> tipo . ID LP param RP LB statement RB funcion
    (59) funcion -> tipo . ID LP param RP LB statement RB

    ID              shift and go to state 24


state 32

    (3) programa1 -> funcion main funcion .

    $end            reduce using rule 3 (programa1 -> funcion main funcion .)


state 33

    (20) vars -> VAR tipo vars1 .

    VOID            reduce using rule 20 (vars -> VAR tipo vars1 .)
    INT             reduce using rule 20 (vars -> VAR tipo vars1 .)
    FLOAT           reduce using rule 20 (vars -> VAR tipo vars1 .)
    CHAR            reduce using rule 20 (vars -> VAR tipo vars1 .)
    $end            reduce using rule 20 (vars -> VAR tipo vars1 .)
    ID              reduce using rule 20 (vars -> VAR tipo vars1 .)
    IF              reduce using rule 20 (vars -> VAR tipo vars1 .)
    VAR             reduce using rule 20 (vars -> VAR tipo vars1 .)
    RB              reduce using rule 20 (vars -> VAR tipo vars1 .)


state 34

    (21) vars -> VAR tipo vars2 .

    VOID            reduce using rule 21 (vars -> VAR tipo vars2 .)
    INT             reduce using rule 21 (vars -> VAR tipo vars2 .)
    FLOAT           reduce using rule 21 (vars -> VAR tipo vars2 .)
    CHAR            reduce using rule 21 (vars -> VAR tipo vars2 .)
    $end            reduce using rule 21 (vars -> VAR tipo vars2 .)
    ID              reduce using rule 21 (vars -> VAR tipo vars2 .)
    IF              reduce using rule 21 (vars -> VAR tipo vars2 .)
    VAR             reduce using rule 21 (vars -> VAR tipo vars2 .)
    RB              reduce using rule 21 (vars -> VAR tipo vars2 .)


state 35

    (22) vars -> VAR tipo vars3 .

    VOID            reduce using rule 22 (vars -> VAR tipo vars3 .)
    INT             reduce using rule 22 (vars -> VAR tipo vars3 .)
    FLOAT           reduce using rule 22 (vars -> VAR tipo vars3 .)
    CHAR            reduce using rule 22 (vars -> VAR tipo vars3 .)
    $end            reduce using rule 22 (vars -> VAR tipo vars3 .)
    ID              reduce using rule 22 (vars -> VAR tipo vars3 .)
    IF              reduce using rule 22 (vars -> VAR tipo vars3 .)
    VAR             reduce using rule 22 (vars -> VAR tipo vars3 .)
    RB              reduce using rule 22 (vars -> VAR tipo vars3 .)


state 36

    (23) vars -> VAR tipo oper_aritmetica .

    VOID            reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    INT             reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    FLOAT           reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    CHAR            reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    $end            reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    ID              reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    IF              reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    VAR             reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)
    RB              reduce using rule 23 (vars -> VAR tipo oper_aritmetica .)


state 37

    (34) varsG -> VAR tipo vars1G .

    VOID            reduce using rule 34 (varsG -> VAR tipo vars1G .)
    INT             reduce using rule 34 (varsG -> VAR tipo vars1G .)
    FLOAT           reduce using rule 34 (varsG -> VAR tipo vars1G .)
    CHAR            reduce using rule 34 (varsG -> VAR tipo vars1G .)
    $end            reduce using rule 34 (varsG -> VAR tipo vars1G .)
    RB              reduce using rule 34 (varsG -> VAR tipo vars1G .)
    ID              reduce using rule 34 (varsG -> VAR tipo vars1G .)
    IF              reduce using rule 34 (varsG -> VAR tipo vars1G .)
    VAR             reduce using rule 34 (varsG -> VAR tipo vars1G .)


state 38

    (35) varsG -> VAR tipo vars2G .

    VOID            reduce using rule 35 (varsG -> VAR tipo vars2G .)
    INT             reduce using rule 35 (varsG -> VAR tipo vars2G .)
    FLOAT           reduce using rule 35 (varsG -> VAR tipo vars2G .)
    CHAR            reduce using rule 35 (varsG -> VAR tipo vars2G .)
    $end            reduce using rule 35 (varsG -> VAR tipo vars2G .)
    RB              reduce using rule 35 (varsG -> VAR tipo vars2G .)
    ID              reduce using rule 35 (varsG -> VAR tipo vars2G .)
    IF              reduce using rule 35 (varsG -> VAR tipo vars2G .)
    VAR             reduce using rule 35 (varsG -> VAR tipo vars2G .)


state 39

    (36) varsG -> VAR tipo vars3G .

    VOID            reduce using rule 36 (varsG -> VAR tipo vars3G .)
    INT             reduce using rule 36 (varsG -> VAR tipo vars3G .)
    FLOAT           reduce using rule 36 (varsG -> VAR tipo vars3G .)
    CHAR            reduce using rule 36 (varsG -> VAR tipo vars3G .)
    $end            reduce using rule 36 (varsG -> VAR tipo vars3G .)
    RB              reduce using rule 36 (varsG -> VAR tipo vars3G .)
    ID              reduce using rule 36 (varsG -> VAR tipo vars3G .)
    IF              reduce using rule 36 (varsG -> VAR tipo vars3G .)
    VAR             reduce using rule 36 (varsG -> VAR tipo vars3G .)


state 40

    (26) vars1 -> ID . SEMICOL
    (27) vars1 -> ID . SEMICOL vars
    (28) vars2 -> ID . IS value COMMA vars2
    (29) vars2 -> ID . IS value COMMA
    (30) vars2 -> ID . IS value SEMICOL vars
    (31) vars3 -> ID . COMMA vars3
    (32) vars3 -> ID . SEMICOL vars
    (33) vars3 -> ID . SEMICOL
    (67) oper_aritmetica -> ID . IS expr SEMICOL
    (38) vars1G -> ID . SEMICOL
    (39) vars1G -> ID . SEMICOL varsG
    (40) vars2G -> ID . IS value check_type COMMA vars2G
    (41) vars2G -> ID . IS value check_type SEMICOL varsG
    (43) vars3G -> ID . COMMA vars3G
    (44) vars3G -> ID . SEMICOL varsG
    (45) vars3G -> ID . SEMICOL

    SEMICOL         shift and go to state 49
    IS              shift and go to state 50
    COMMA           shift and go to state 51


state 41

    (42) vars2G -> empty .

    VOID            reduce using rule 42 (vars2G -> empty .)
    INT             reduce using rule 42 (vars2G -> empty .)
    FLOAT           reduce using rule 42 (vars2G -> empty .)
    CHAR            reduce using rule 42 (vars2G -> empty .)
    $end            reduce using rule 42 (vars2G -> empty .)
    ID              reduce using rule 42 (vars2G -> empty .)
    IF              reduce using rule 42 (vars2G -> empty .)
    VAR             reduce using rule 42 (vars2G -> empty .)
    RB              reduce using rule 42 (vars2G -> empty .)


state 42

    (34) varsG -> VAR . tipo vars1G
    (35) varsG -> VAR . tipo vars2G
    (36) varsG -> VAR . tipo vars3G
    (37) varsG -> VAR . LB varsG RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

    LB              shift and go to state 23
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    tipo                           shift and go to state 52

state 43

    (37) varsG -> VAR LB varsG . RB

    RB              shift and go to state 53


state 44

    (57) funcion -> tipo ID LP . param RP LB statement RB funcion
    (59) funcion -> tipo ID LP . param RP LB statement RB
    (60) param -> .

    RP              reduce using rule 60 (param -> .)

    param                          shift and go to state 54

state 45

    (13) main -> tipo MAIN LP . RP LB statement RB

    RP              shift and go to state 55


state 46

    (56) funcion -> VOID ID LP . param RP LB statement RB funcion
    (58) funcion -> VOID ID LP . param RP LB statement RB
    (60) param -> .

    RP              reduce using rule 60 (param -> .)

    param                          shift and go to state 56

state 47

    (14) main -> VOID tipo MAIN . LP RP LB statement RB

    LP              shift and go to state 57


state 48

    (2) programa1 -> vars funcion main funcion .

    $end            reduce using rule 2 (programa1 -> vars funcion main funcion .)


state 49

    (26) vars1 -> ID SEMICOL .
    (27) vars1 -> ID SEMICOL . vars
    (32) vars3 -> ID SEMICOL . vars
    (33) vars3 -> ID SEMICOL .
    (38) vars1G -> ID SEMICOL .
    (39) vars1G -> ID SEMICOL . varsG
    (44) vars3G -> ID SEMICOL . varsG
    (45) vars3G -> ID SEMICOL .
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB
    (79) empty -> .

  ! reduce/reduce conflict for VOID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for VAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for RB resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for VOID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for VAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for RB resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for VOID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for VAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for RB resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 26 (vars1 -> ID SEMICOL .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RB resolved using rule 26 (vars1 -> ID SEMICOL .)
    VOID            reduce using rule 26 (vars1 -> ID SEMICOL .)
    INT             reduce using rule 26 (vars1 -> ID SEMICOL .)
    FLOAT           reduce using rule 26 (vars1 -> ID SEMICOL .)
    CHAR            reduce using rule 26 (vars1 -> ID SEMICOL .)
    $end            reduce using rule 26 (vars1 -> ID SEMICOL .)
    ID              reduce using rule 26 (vars1 -> ID SEMICOL .)
    IF              reduce using rule 26 (vars1 -> ID SEMICOL .)
    RB              reduce using rule 26 (vars1 -> ID SEMICOL .)
    VAR             shift and go to state 10

  ! VAR             [ reduce using rule 26 (vars1 -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! INT             [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! FLOAT           [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! CHAR            [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! $end            [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! ID              [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! IF              [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! VAR             [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! RB              [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! INT             [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! FLOAT           [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! CHAR            [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! $end            [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! ID              [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! IF              [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! VAR             [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! RB              [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! INT             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! FLOAT           [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! CHAR            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! $end            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! ID              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! IF              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! VAR             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! RB              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 79 (empty -> .) ]
  ! INT             [ reduce using rule 79 (empty -> .) ]
  ! FLOAT           [ reduce using rule 79 (empty -> .) ]
  ! CHAR            [ reduce using rule 79 (empty -> .) ]
  ! $end            [ reduce using rule 79 (empty -> .) ]
  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]
  ! RB              [ reduce using rule 79 (empty -> .) ]

    vars                           shift and go to state 58
    varsG                          shift and go to state 59
    empty                          shift and go to state 60

state 50

    (28) vars2 -> ID IS . value COMMA vars2
    (29) vars2 -> ID IS . value COMMA
    (30) vars2 -> ID IS . value SEMICOL vars
    (67) oper_aritmetica -> ID IS . expr SEMICOL
    (40) vars2G -> ID IS . value check_type COMMA vars2G
    (41) vars2G -> ID IS . value check_type SEMICOL varsG
    (49) value -> . CTE_F
    (50) value -> . CTE_I
    (51) value -> . ID
    (52) value -> . CTE_C
    (53) value -> . COMILLA ID COMILLA
    (54) value -> . COMILLAS ID COMILLAS
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_F           shift and go to state 64
    CTE_I           shift and go to state 65
    ID              shift and go to state 61
    CTE_C           shift and go to state 66
    COMILLA         shift and go to state 67
    COMILLAS        shift and go to state 68

    value                          shift and go to state 62
    expr                           shift and go to state 63

state 51

    (31) vars3 -> ID COMMA . vars3
    (43) vars3G -> ID COMMA . vars3G
    (31) vars3 -> . ID COMMA vars3
    (32) vars3 -> . ID SEMICOL vars
    (33) vars3 -> . ID SEMICOL
    (43) vars3G -> . ID COMMA vars3G
    (44) vars3G -> . ID SEMICOL varsG
    (45) vars3G -> . ID SEMICOL

    ID              shift and go to state 69

    vars3                          shift and go to state 70
    vars3G                         shift and go to state 71

state 52

    (34) varsG -> VAR tipo . vars1G
    (35) varsG -> VAR tipo . vars2G
    (36) varsG -> VAR tipo . vars3G
    (38) vars1G -> . ID SEMICOL
    (39) vars1G -> . ID SEMICOL varsG
    (40) vars2G -> . ID IS value check_type COMMA vars2G
    (41) vars2G -> . ID IS value check_type SEMICOL varsG
    (42) vars2G -> . empty
    (43) vars3G -> . ID COMMA vars3G
    (44) vars3G -> . ID SEMICOL varsG
    (45) vars3G -> . ID SEMICOL
    (79) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 72
    RB              reduce using rule 79 (empty -> .)
    VOID            reduce using rule 79 (empty -> .)
    INT             reduce using rule 79 (empty -> .)
    FLOAT           reduce using rule 79 (empty -> .)
    CHAR            reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    VAR             reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]

    vars1G                         shift and go to state 37
    vars2G                         shift and go to state 38
    vars3G                         shift and go to state 39
    empty                          shift and go to state 41

state 53

    (37) varsG -> VAR LB varsG RB .

    VOID            reduce using rule 37 (varsG -> VAR LB varsG RB .)
    INT             reduce using rule 37 (varsG -> VAR LB varsG RB .)
    FLOAT           reduce using rule 37 (varsG -> VAR LB varsG RB .)
    CHAR            reduce using rule 37 (varsG -> VAR LB varsG RB .)
    $end            reduce using rule 37 (varsG -> VAR LB varsG RB .)
    RB              reduce using rule 37 (varsG -> VAR LB varsG RB .)
    ID              reduce using rule 37 (varsG -> VAR LB varsG RB .)
    IF              reduce using rule 37 (varsG -> VAR LB varsG RB .)
    VAR             reduce using rule 37 (varsG -> VAR LB varsG RB .)


state 54

    (57) funcion -> tipo ID LP param . RP LB statement RB funcion
    (59) funcion -> tipo ID LP param . RP LB statement RB

    RP              shift and go to state 73


state 55

    (13) main -> tipo MAIN LP RP . LB statement RB

    LB              shift and go to state 74


state 56

    (56) funcion -> VOID ID LP param . RP LB statement RB funcion
    (58) funcion -> VOID ID LP param . RP LB statement RB

    RP              shift and go to state 75


state 57

    (14) main -> VOID tipo MAIN LP . RP LB statement RB

    RP              shift and go to state 76


state 58

    (27) vars1 -> ID SEMICOL vars .
    (32) vars3 -> ID SEMICOL vars .

  ! reduce/reduce conflict for VOID resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for INT resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for FLOAT resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for CHAR resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for $end resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for ID resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for IF resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for VAR resolved using rule 27 (vars1 -> ID SEMICOL vars .)
  ! reduce/reduce conflict for RB resolved using rule 27 (vars1 -> ID SEMICOL vars .)
    VOID            reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    INT             reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    FLOAT           reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    CHAR            reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    $end            reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    ID              reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    IF              reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    VAR             reduce using rule 27 (vars1 -> ID SEMICOL vars .)
    RB              reduce using rule 27 (vars1 -> ID SEMICOL vars .)

  ! VOID            [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! INT             [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! FLOAT           [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! CHAR            [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! $end            [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! ID              [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! IF              [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! VAR             [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]
  ! RB              [ reduce using rule 32 (vars3 -> ID SEMICOL vars .) ]


state 59

    (39) vars1G -> ID SEMICOL varsG .
    (44) vars3G -> ID SEMICOL varsG .
    (24) vars -> varsG .

  ! reduce/reduce conflict for VOID resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for INT resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for FLOAT resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for CHAR resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for $end resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for ID resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for IF resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for VAR resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for RB resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for VOID resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for INT resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for FLOAT resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for CHAR resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for $end resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for ID resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for IF resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for VAR resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for RB resolved using rule 24 (vars -> varsG .)
    VOID            reduce using rule 24 (vars -> varsG .)
    INT             reduce using rule 24 (vars -> varsG .)
    FLOAT           reduce using rule 24 (vars -> varsG .)
    CHAR            reduce using rule 24 (vars -> varsG .)
    $end            reduce using rule 24 (vars -> varsG .)
    ID              reduce using rule 24 (vars -> varsG .)
    IF              reduce using rule 24 (vars -> varsG .)
    VAR             reduce using rule 24 (vars -> varsG .)
    RB              reduce using rule 24 (vars -> varsG .)

  ! VOID            [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! INT             [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! FLOAT           [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! CHAR            [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! $end            [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! ID              [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! IF              [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! VAR             [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! RB              [ reduce using rule 39 (vars1G -> ID SEMICOL varsG .) ]
  ! VOID            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! INT             [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! FLOAT           [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! CHAR            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! $end            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! ID              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! IF              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! VAR             [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! RB              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]


state 60

    (25) vars -> empty .

    VOID            reduce using rule 25 (vars -> empty .)
    INT             reduce using rule 25 (vars -> empty .)
    FLOAT           reduce using rule 25 (vars -> empty .)
    CHAR            reduce using rule 25 (vars -> empty .)
    $end            reduce using rule 25 (vars -> empty .)
    ID              reduce using rule 25 (vars -> empty .)
    IF              reduce using rule 25 (vars -> empty .)
    VAR             reduce using rule 25 (vars -> empty .)
    RB              reduce using rule 25 (vars -> empty .)


state 61

    (51) value -> ID .
    (74) expr -> ID .
    (75) expr -> ID . row
    (76) expr -> ID . matrix
    (77) row -> . LC expr RC
    (78) matrix -> . row row

  ! reduce/reduce conflict for SEMICOL resolved using rule 51 (value -> ID .)
    COMMA           reduce using rule 51 (value -> ID .)
    SEMICOL         reduce using rule 51 (value -> ID .)
    MUL             reduce using rule 74 (expr -> ID .)
    DIV             reduce using rule 74 (expr -> ID .)
    PLUS            reduce using rule 74 (expr -> ID .)
    MINUS           reduce using rule 74 (expr -> ID .)
    LC              shift and go to state 79

  ! SEMICOL         [ reduce using rule 74 (expr -> ID .) ]

    row                            shift and go to state 77
    matrix                         shift and go to state 78

state 62

    (28) vars2 -> ID IS value . COMMA vars2
    (29) vars2 -> ID IS value . COMMA
    (30) vars2 -> ID IS value . SEMICOL vars
    (40) vars2G -> ID IS value . check_type COMMA vars2G
    (41) vars2G -> ID IS value . check_type SEMICOL varsG
    (55) check_type -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for SEMICOL resolved as shift
    COMMA           shift and go to state 80
    SEMICOL         shift and go to state 81

  ! COMMA           [ reduce using rule 55 (check_type -> .) ]
  ! SEMICOL         [ reduce using rule 55 (check_type -> .) ]

    check_type                     shift and go to state 82

state 63

    (67) oper_aritmetica -> ID IS expr . SEMICOL
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    SEMICOL         shift and go to state 83
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 64

    (49) value -> CTE_F .
    (73) expr -> CTE_F .

  ! reduce/reduce conflict for SEMICOL resolved using rule 49 (value -> CTE_F .)
    COMMA           reduce using rule 49 (value -> CTE_F .)
    SEMICOL         reduce using rule 49 (value -> CTE_F .)
    MUL             reduce using rule 73 (expr -> CTE_F .)
    DIV             reduce using rule 73 (expr -> CTE_F .)
    PLUS            reduce using rule 73 (expr -> CTE_F .)
    MINUS           reduce using rule 73 (expr -> CTE_F .)

  ! SEMICOL         [ reduce using rule 73 (expr -> CTE_F .) ]


state 65

    (50) value -> CTE_I .
    (72) expr -> CTE_I .

  ! reduce/reduce conflict for SEMICOL resolved using rule 50 (value -> CTE_I .)
    COMMA           reduce using rule 50 (value -> CTE_I .)
    SEMICOL         reduce using rule 50 (value -> CTE_I .)
    MUL             reduce using rule 72 (expr -> CTE_I .)
    DIV             reduce using rule 72 (expr -> CTE_I .)
    PLUS            reduce using rule 72 (expr -> CTE_I .)
    MINUS           reduce using rule 72 (expr -> CTE_I .)

  ! SEMICOL         [ reduce using rule 72 (expr -> CTE_I .) ]


state 66

    (52) value -> CTE_C .

    COMMA           reduce using rule 52 (value -> CTE_C .)
    SEMICOL         reduce using rule 52 (value -> CTE_C .)


state 67

    (53) value -> COMILLA . ID COMILLA

    ID              shift and go to state 88


state 68

    (54) value -> COMILLAS . ID COMILLAS

    ID              shift and go to state 89


state 69

    (31) vars3 -> ID . COMMA vars3
    (32) vars3 -> ID . SEMICOL vars
    (33) vars3 -> ID . SEMICOL
    (43) vars3G -> ID . COMMA vars3G
    (44) vars3G -> ID . SEMICOL varsG
    (45) vars3G -> ID . SEMICOL

    COMMA           shift and go to state 51
    SEMICOL         shift and go to state 90


state 70

    (31) vars3 -> ID COMMA vars3 .

    VOID            reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    INT             reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    FLOAT           reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    CHAR            reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    $end            reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    ID              reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    IF              reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    VAR             reduce using rule 31 (vars3 -> ID COMMA vars3 .)
    RB              reduce using rule 31 (vars3 -> ID COMMA vars3 .)


state 71

    (43) vars3G -> ID COMMA vars3G .

    VOID            reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    INT             reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    FLOAT           reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    CHAR            reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    $end            reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    ID              reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    IF              reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    VAR             reduce using rule 43 (vars3G -> ID COMMA vars3G .)
    RB              reduce using rule 43 (vars3G -> ID COMMA vars3G .)


state 72

    (38) vars1G -> ID . SEMICOL
    (39) vars1G -> ID . SEMICOL varsG
    (40) vars2G -> ID . IS value check_type COMMA vars2G
    (41) vars2G -> ID . IS value check_type SEMICOL varsG
    (43) vars3G -> ID . COMMA vars3G
    (44) vars3G -> ID . SEMICOL varsG
    (45) vars3G -> ID . SEMICOL

    SEMICOL         shift and go to state 91
    IS              shift and go to state 92
    COMMA           shift and go to state 93


state 73

    (57) funcion -> tipo ID LP param RP . LB statement RB funcion
    (59) funcion -> tipo ID LP param RP . LB statement RB

    LB              shift and go to state 94


state 74

    (13) main -> tipo MAIN LP RP LB . statement RB
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 95
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 75

    (56) funcion -> VOID ID LP param RP . LB statement RB funcion
    (58) funcion -> VOID ID LP param RP . LB statement RB

    LB              shift and go to state 102


state 76

    (14) main -> VOID tipo MAIN LP RP . LB statement RB

    LB              shift and go to state 103


state 77

    (75) expr -> ID row .
    (78) matrix -> row . row
    (77) row -> . LC expr RC

    SEMICOL         reduce using rule 75 (expr -> ID row .)
    MUL             reduce using rule 75 (expr -> ID row .)
    DIV             reduce using rule 75 (expr -> ID row .)
    PLUS            reduce using rule 75 (expr -> ID row .)
    MINUS           reduce using rule 75 (expr -> ID row .)
    RC              reduce using rule 75 (expr -> ID row .)
    GT              reduce using rule 75 (expr -> ID row .)
    LT              reduce using rule 75 (expr -> ID row .)
    EQUAL           reduce using rule 75 (expr -> ID row .)
    NEQ             reduce using rule 75 (expr -> ID row .)
    GEQ             reduce using rule 75 (expr -> ID row .)
    LEQ             reduce using rule 75 (expr -> ID row .)
    RP              reduce using rule 75 (expr -> ID row .)
    LC              shift and go to state 79

    row                            shift and go to state 104

state 78

    (76) expr -> ID matrix .

    SEMICOL         reduce using rule 76 (expr -> ID matrix .)
    MUL             reduce using rule 76 (expr -> ID matrix .)
    DIV             reduce using rule 76 (expr -> ID matrix .)
    PLUS            reduce using rule 76 (expr -> ID matrix .)
    MINUS           reduce using rule 76 (expr -> ID matrix .)
    RC              reduce using rule 76 (expr -> ID matrix .)
    GT              reduce using rule 76 (expr -> ID matrix .)
    LT              reduce using rule 76 (expr -> ID matrix .)
    EQUAL           reduce using rule 76 (expr -> ID matrix .)
    NEQ             reduce using rule 76 (expr -> ID matrix .)
    GEQ             reduce using rule 76 (expr -> ID matrix .)
    LEQ             reduce using rule 76 (expr -> ID matrix .)
    RP              reduce using rule 76 (expr -> ID matrix .)


state 79

    (77) row -> LC . expr RC
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 105

state 80

    (28) vars2 -> ID IS value COMMA . vars2
    (29) vars2 -> ID IS value COMMA .
    (28) vars2 -> . ID IS value COMMA vars2
    (29) vars2 -> . ID IS value COMMA
    (30) vars2 -> . ID IS value SEMICOL vars

  ! shift/reduce conflict for ID resolved as shift
    VOID            reduce using rule 29 (vars2 -> ID IS value COMMA .)
    INT             reduce using rule 29 (vars2 -> ID IS value COMMA .)
    FLOAT           reduce using rule 29 (vars2 -> ID IS value COMMA .)
    CHAR            reduce using rule 29 (vars2 -> ID IS value COMMA .)
    $end            reduce using rule 29 (vars2 -> ID IS value COMMA .)
    IF              reduce using rule 29 (vars2 -> ID IS value COMMA .)
    VAR             reduce using rule 29 (vars2 -> ID IS value COMMA .)
    RB              reduce using rule 29 (vars2 -> ID IS value COMMA .)
    ID              shift and go to state 109

  ! ID              [ reduce using rule 29 (vars2 -> ID IS value COMMA .) ]

    vars2                          shift and go to state 110

state 81

    (30) vars2 -> ID IS value SEMICOL . vars
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB
    (79) empty -> .

  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 10
    VOID            reduce using rule 79 (empty -> .)
    INT             reduce using rule 79 (empty -> .)
    FLOAT           reduce using rule 79 (empty -> .)
    CHAR            reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    ID              reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    RB              reduce using rule 79 (empty -> .)

  ! VAR             [ reduce using rule 79 (empty -> .) ]

    vars                           shift and go to state 111
    varsG                          shift and go to state 12
    empty                          shift and go to state 60

state 82

    (40) vars2G -> ID IS value check_type . COMMA vars2G
    (41) vars2G -> ID IS value check_type . SEMICOL varsG

    COMMA           shift and go to state 112
    SEMICOL         shift and go to state 113


state 83

    (67) oper_aritmetica -> ID IS expr SEMICOL .

    VOID            reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    INT             reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    FLOAT           reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    CHAR            reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    $end            reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    ID              reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    IF              reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    VAR             reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)
    RB              reduce using rule 67 (oper_aritmetica -> ID IS expr SEMICOL .)


state 84

    (68) expr -> expr MUL . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 114

state 85

    (69) expr -> expr DIV . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 115

state 86

    (70) expr -> expr PLUS . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 116

state 87

    (71) expr -> expr MINUS . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 117

state 88

    (53) value -> COMILLA ID . COMILLA

    COMILLA         shift and go to state 118


state 89

    (54) value -> COMILLAS ID . COMILLAS

    COMILLAS        shift and go to state 119


state 90

    (32) vars3 -> ID SEMICOL . vars
    (33) vars3 -> ID SEMICOL .
    (44) vars3G -> ID SEMICOL . varsG
    (45) vars3G -> ID SEMICOL .
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB
    (79) empty -> .

  ! reduce/reduce conflict for VOID resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for VAR resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for RB resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 33 (vars3 -> ID SEMICOL .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RB resolved using rule 33 (vars3 -> ID SEMICOL .)
    VOID            reduce using rule 33 (vars3 -> ID SEMICOL .)
    INT             reduce using rule 33 (vars3 -> ID SEMICOL .)
    FLOAT           reduce using rule 33 (vars3 -> ID SEMICOL .)
    CHAR            reduce using rule 33 (vars3 -> ID SEMICOL .)
    $end            reduce using rule 33 (vars3 -> ID SEMICOL .)
    ID              reduce using rule 33 (vars3 -> ID SEMICOL .)
    IF              reduce using rule 33 (vars3 -> ID SEMICOL .)
    RB              reduce using rule 33 (vars3 -> ID SEMICOL .)
    VAR             shift and go to state 10

  ! VAR             [ reduce using rule 33 (vars3 -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! INT             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! FLOAT           [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! CHAR            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! $end            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! ID              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! IF              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! VAR             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! RB              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 79 (empty -> .) ]
  ! INT             [ reduce using rule 79 (empty -> .) ]
  ! FLOAT           [ reduce using rule 79 (empty -> .) ]
  ! CHAR            [ reduce using rule 79 (empty -> .) ]
  ! $end            [ reduce using rule 79 (empty -> .) ]
  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]
  ! RB              [ reduce using rule 79 (empty -> .) ]

    vars                           shift and go to state 120
    varsG                          shift and go to state 121
    empty                          shift and go to state 60

state 91

    (38) vars1G -> ID SEMICOL .
    (39) vars1G -> ID SEMICOL . varsG
    (44) vars3G -> ID SEMICOL . varsG
    (45) vars3G -> ID SEMICOL .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! reduce/reduce conflict for RB resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for VOID resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for INT resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for CHAR resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for $end resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for ID resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for IF resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! reduce/reduce conflict for VAR resolved using rule 38 (vars1G -> ID SEMICOL .)
  ! shift/reduce conflict for VAR resolved as shift
    RB              reduce using rule 38 (vars1G -> ID SEMICOL .)
    VOID            reduce using rule 38 (vars1G -> ID SEMICOL .)
    INT             reduce using rule 38 (vars1G -> ID SEMICOL .)
    FLOAT           reduce using rule 38 (vars1G -> ID SEMICOL .)
    CHAR            reduce using rule 38 (vars1G -> ID SEMICOL .)
    $end            reduce using rule 38 (vars1G -> ID SEMICOL .)
    ID              reduce using rule 38 (vars1G -> ID SEMICOL .)
    IF              reduce using rule 38 (vars1G -> ID SEMICOL .)
    VAR             shift and go to state 42

  ! VAR             [ reduce using rule 38 (vars1G -> ID SEMICOL .) ]
  ! RB              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! VOID            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! INT             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! FLOAT           [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! CHAR            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! $end            [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! ID              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! IF              [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]
  ! VAR             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]

    varsG                          shift and go to state 122

state 92

    (40) vars2G -> ID IS . value check_type COMMA vars2G
    (41) vars2G -> ID IS . value check_type SEMICOL varsG
    (49) value -> . CTE_F
    (50) value -> . CTE_I
    (51) value -> . ID
    (52) value -> . CTE_C
    (53) value -> . COMILLA ID COMILLA
    (54) value -> . COMILLAS ID COMILLAS

    CTE_F           shift and go to state 125
    CTE_I           shift and go to state 126
    ID              shift and go to state 123
    CTE_C           shift and go to state 66
    COMILLA         shift and go to state 67
    COMILLAS        shift and go to state 68

    value                          shift and go to state 124

state 93

    (43) vars3G -> ID COMMA . vars3G
    (43) vars3G -> . ID COMMA vars3G
    (44) vars3G -> . ID SEMICOL varsG
    (45) vars3G -> . ID SEMICOL

    ID              shift and go to state 127

    vars3G                         shift and go to state 71

state 94

    (57) funcion -> tipo ID LP param RP LB . statement RB funcion
    (59) funcion -> tipo ID LP param RP LB . statement RB
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 128
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 95

    (13) main -> tipo MAIN LP RP LB statement . RB

    RB              shift and go to state 129


state 96

    (15) statement -> asignacion . SEMICOL statement

    SEMICOL         shift and go to state 130


state 97

    (16) statement -> if . statement
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    if                             shift and go to state 97
    statement                      shift and go to state 131
    asignacion                     shift and go to state 96
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 98

    (17) statement -> vars . statement
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    vars                           shift and go to state 98
    statement                      shift and go to state 132
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 99

    (18) statement -> empty .
    (25) vars -> empty .

  ! reduce/reduce conflict for RB resolved using rule 18 (statement -> empty .)
    RB              reduce using rule 18 (statement -> empty .)
    ID              reduce using rule 25 (vars -> empty .)
    IF              reduce using rule 25 (vars -> empty .)
    VAR             reduce using rule 25 (vars -> empty .)

  ! RB              [ reduce using rule 25 (vars -> empty .) ]


state 100

    (19) asignacion -> ID . IS value

    IS              shift and go to state 133


state 101

    (80) if -> IF . LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> IF . LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> IF . LP expression RP check_bool gotof LB statement RB guarda_salto else

    LP              shift and go to state 134


state 102

    (56) funcion -> VOID ID LP param RP LB . statement RB funcion
    (58) funcion -> VOID ID LP param RP LB . statement RB
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 135
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 103

    (14) main -> VOID tipo MAIN LP RP LB . statement RB
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 136
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 104

    (78) matrix -> row row .

    SEMICOL         reduce using rule 78 (matrix -> row row .)
    MUL             reduce using rule 78 (matrix -> row row .)
    DIV             reduce using rule 78 (matrix -> row row .)
    PLUS            reduce using rule 78 (matrix -> row row .)
    MINUS           reduce using rule 78 (matrix -> row row .)
    RC              reduce using rule 78 (matrix -> row row .)
    GT              reduce using rule 78 (matrix -> row row .)
    LT              reduce using rule 78 (matrix -> row row .)
    EQUAL           reduce using rule 78 (matrix -> row row .)
    NEQ             reduce using rule 78 (matrix -> row row .)
    GEQ             reduce using rule 78 (matrix -> row row .)
    LEQ             reduce using rule 78 (matrix -> row row .)
    RP              reduce using rule 78 (matrix -> row row .)


state 105

    (77) row -> LC expr . RC
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RC              shift and go to state 137
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 106

    (72) expr -> CTE_I .

    RC              reduce using rule 72 (expr -> CTE_I .)
    MUL             reduce using rule 72 (expr -> CTE_I .)
    DIV             reduce using rule 72 (expr -> CTE_I .)
    PLUS            reduce using rule 72 (expr -> CTE_I .)
    MINUS           reduce using rule 72 (expr -> CTE_I .)
    SEMICOL         reduce using rule 72 (expr -> CTE_I .)
    GT              reduce using rule 72 (expr -> CTE_I .)
    LT              reduce using rule 72 (expr -> CTE_I .)
    EQUAL           reduce using rule 72 (expr -> CTE_I .)
    NEQ             reduce using rule 72 (expr -> CTE_I .)
    GEQ             reduce using rule 72 (expr -> CTE_I .)
    LEQ             reduce using rule 72 (expr -> CTE_I .)
    RP              reduce using rule 72 (expr -> CTE_I .)


state 107

    (73) expr -> CTE_F .

    RC              reduce using rule 73 (expr -> CTE_F .)
    MUL             reduce using rule 73 (expr -> CTE_F .)
    DIV             reduce using rule 73 (expr -> CTE_F .)
    PLUS            reduce using rule 73 (expr -> CTE_F .)
    MINUS           reduce using rule 73 (expr -> CTE_F .)
    SEMICOL         reduce using rule 73 (expr -> CTE_F .)
    GT              reduce using rule 73 (expr -> CTE_F .)
    LT              reduce using rule 73 (expr -> CTE_F .)
    EQUAL           reduce using rule 73 (expr -> CTE_F .)
    NEQ             reduce using rule 73 (expr -> CTE_F .)
    GEQ             reduce using rule 73 (expr -> CTE_F .)
    LEQ             reduce using rule 73 (expr -> CTE_F .)
    RP              reduce using rule 73 (expr -> CTE_F .)


state 108

    (74) expr -> ID .
    (75) expr -> ID . row
    (76) expr -> ID . matrix
    (77) row -> . LC expr RC
    (78) matrix -> . row row

    RC              reduce using rule 74 (expr -> ID .)
    MUL             reduce using rule 74 (expr -> ID .)
    DIV             reduce using rule 74 (expr -> ID .)
    PLUS            reduce using rule 74 (expr -> ID .)
    MINUS           reduce using rule 74 (expr -> ID .)
    SEMICOL         reduce using rule 74 (expr -> ID .)
    GT              reduce using rule 74 (expr -> ID .)
    LT              reduce using rule 74 (expr -> ID .)
    EQUAL           reduce using rule 74 (expr -> ID .)
    NEQ             reduce using rule 74 (expr -> ID .)
    GEQ             reduce using rule 74 (expr -> ID .)
    LEQ             reduce using rule 74 (expr -> ID .)
    RP              reduce using rule 74 (expr -> ID .)
    LC              shift and go to state 79

    row                            shift and go to state 77
    matrix                         shift and go to state 78

state 109

    (28) vars2 -> ID . IS value COMMA vars2
    (29) vars2 -> ID . IS value COMMA
    (30) vars2 -> ID . IS value SEMICOL vars

    IS              shift and go to state 138


state 110

    (28) vars2 -> ID IS value COMMA vars2 .

    VOID            reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    INT             reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    FLOAT           reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    CHAR            reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    $end            reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    ID              reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    IF              reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    VAR             reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)
    RB              reduce using rule 28 (vars2 -> ID IS value COMMA vars2 .)


state 111

    (30) vars2 -> ID IS value SEMICOL vars .

    VOID            reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    INT             reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    FLOAT           reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    CHAR            reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    $end            reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    ID              reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    IF              reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    VAR             reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)
    RB              reduce using rule 30 (vars2 -> ID IS value SEMICOL vars .)


state 112

    (40) vars2G -> ID IS value check_type COMMA . vars2G
    (40) vars2G -> . ID IS value check_type COMMA vars2G
    (41) vars2G -> . ID IS value check_type SEMICOL varsG
    (42) vars2G -> . empty
    (79) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 139
    RB              reduce using rule 79 (empty -> .)
    VOID            reduce using rule 79 (empty -> .)
    INT             reduce using rule 79 (empty -> .)
    FLOAT           reduce using rule 79 (empty -> .)
    CHAR            reduce using rule 79 (empty -> .)
    $end            reduce using rule 79 (empty -> .)
    IF              reduce using rule 79 (empty -> .)
    VAR             reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]

    vars2G                         shift and go to state 140
    empty                          shift and go to state 41

state 113

    (41) vars2G -> ID IS value check_type SEMICOL . varsG
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

    VAR             shift and go to state 42

    varsG                          shift and go to state 141

state 114

    (68) expr -> expr MUL expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    SEMICOL         reduce using rule 68 (expr -> expr MUL expr .)
    MUL             reduce using rule 68 (expr -> expr MUL expr .)
    DIV             reduce using rule 68 (expr -> expr MUL expr .)
    PLUS            reduce using rule 68 (expr -> expr MUL expr .)
    MINUS           reduce using rule 68 (expr -> expr MUL expr .)
    RC              reduce using rule 68 (expr -> expr MUL expr .)
    GT              reduce using rule 68 (expr -> expr MUL expr .)
    LT              reduce using rule 68 (expr -> expr MUL expr .)
    EQUAL           reduce using rule 68 (expr -> expr MUL expr .)
    NEQ             reduce using rule 68 (expr -> expr MUL expr .)
    GEQ             reduce using rule 68 (expr -> expr MUL expr .)
    LEQ             reduce using rule 68 (expr -> expr MUL expr .)
    RP              reduce using rule 68 (expr -> expr MUL expr .)

  ! MUL             [ shift and go to state 84 ]
  ! DIV             [ shift and go to state 85 ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]


state 115

    (69) expr -> expr DIV expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    SEMICOL         reduce using rule 69 (expr -> expr DIV expr .)
    MUL             reduce using rule 69 (expr -> expr DIV expr .)
    DIV             reduce using rule 69 (expr -> expr DIV expr .)
    PLUS            reduce using rule 69 (expr -> expr DIV expr .)
    MINUS           reduce using rule 69 (expr -> expr DIV expr .)
    RC              reduce using rule 69 (expr -> expr DIV expr .)
    GT              reduce using rule 69 (expr -> expr DIV expr .)
    LT              reduce using rule 69 (expr -> expr DIV expr .)
    EQUAL           reduce using rule 69 (expr -> expr DIV expr .)
    NEQ             reduce using rule 69 (expr -> expr DIV expr .)
    GEQ             reduce using rule 69 (expr -> expr DIV expr .)
    LEQ             reduce using rule 69 (expr -> expr DIV expr .)
    RP              reduce using rule 69 (expr -> expr DIV expr .)

  ! MUL             [ shift and go to state 84 ]
  ! DIV             [ shift and go to state 85 ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]


state 116

    (70) expr -> expr PLUS expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    SEMICOL         reduce using rule 70 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 70 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 70 (expr -> expr PLUS expr .)
    RC              reduce using rule 70 (expr -> expr PLUS expr .)
    GT              reduce using rule 70 (expr -> expr PLUS expr .)
    LT              reduce using rule 70 (expr -> expr PLUS expr .)
    EQUAL           reduce using rule 70 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 70 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 70 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 70 (expr -> expr PLUS expr .)
    RP              reduce using rule 70 (expr -> expr PLUS expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85

  ! MUL             [ reduce using rule 70 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 70 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]


state 117

    (71) expr -> expr MINUS expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    SEMICOL         reduce using rule 71 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 71 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 71 (expr -> expr MINUS expr .)
    RC              reduce using rule 71 (expr -> expr MINUS expr .)
    GT              reduce using rule 71 (expr -> expr MINUS expr .)
    LT              reduce using rule 71 (expr -> expr MINUS expr .)
    EQUAL           reduce using rule 71 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 71 (expr -> expr MINUS expr .)
    GEQ             reduce using rule 71 (expr -> expr MINUS expr .)
    LEQ             reduce using rule 71 (expr -> expr MINUS expr .)
    RP              reduce using rule 71 (expr -> expr MINUS expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85

  ! MUL             [ reduce using rule 71 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 71 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 86 ]
  ! MINUS           [ shift and go to state 87 ]


state 118

    (53) value -> COMILLA ID COMILLA .

    COMMA           reduce using rule 53 (value -> COMILLA ID COMILLA .)
    SEMICOL         reduce using rule 53 (value -> COMILLA ID COMILLA .)


state 119

    (54) value -> COMILLAS ID COMILLAS .

    COMMA           reduce using rule 54 (value -> COMILLAS ID COMILLAS .)
    SEMICOL         reduce using rule 54 (value -> COMILLAS ID COMILLAS .)


state 120

    (32) vars3 -> ID SEMICOL vars .

    VOID            reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    INT             reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    FLOAT           reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    CHAR            reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    $end            reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    ID              reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    IF              reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    VAR             reduce using rule 32 (vars3 -> ID SEMICOL vars .)
    RB              reduce using rule 32 (vars3 -> ID SEMICOL vars .)


state 121

    (44) vars3G -> ID SEMICOL varsG .
    (24) vars -> varsG .

  ! reduce/reduce conflict for VOID resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for INT resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for FLOAT resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for CHAR resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for $end resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for ID resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for IF resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for VAR resolved using rule 24 (vars -> varsG .)
  ! reduce/reduce conflict for RB resolved using rule 24 (vars -> varsG .)
    VOID            reduce using rule 24 (vars -> varsG .)
    INT             reduce using rule 24 (vars -> varsG .)
    FLOAT           reduce using rule 24 (vars -> varsG .)
    CHAR            reduce using rule 24 (vars -> varsG .)
    $end            reduce using rule 24 (vars -> varsG .)
    ID              reduce using rule 24 (vars -> varsG .)
    IF              reduce using rule 24 (vars -> varsG .)
    VAR             reduce using rule 24 (vars -> varsG .)
    RB              reduce using rule 24 (vars -> varsG .)

  ! VOID            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! INT             [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! FLOAT           [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! CHAR            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! $end            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! ID              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! IF              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! VAR             [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! RB              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]


state 122

    (39) vars1G -> ID SEMICOL varsG .
    (44) vars3G -> ID SEMICOL varsG .

  ! reduce/reduce conflict for RB resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for VOID resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for INT resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for FLOAT resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for CHAR resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for $end resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for ID resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for IF resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
  ! reduce/reduce conflict for VAR resolved using rule 39 (vars1G -> ID SEMICOL varsG .)
    RB              reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    VOID            reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    INT             reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    FLOAT           reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    CHAR            reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    $end            reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    ID              reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    IF              reduce using rule 39 (vars1G -> ID SEMICOL varsG .)
    VAR             reduce using rule 39 (vars1G -> ID SEMICOL varsG .)

  ! RB              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! VOID            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! INT             [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! FLOAT           [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! CHAR            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! $end            [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! ID              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! IF              [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]
  ! VAR             [ reduce using rule 44 (vars3G -> ID SEMICOL varsG .) ]


state 123

    (51) value -> ID .

    COMMA           reduce using rule 51 (value -> ID .)
    SEMICOL         reduce using rule 51 (value -> ID .)


state 124

    (40) vars2G -> ID IS value . check_type COMMA vars2G
    (41) vars2G -> ID IS value . check_type SEMICOL varsG
    (55) check_type -> .

    COMMA           reduce using rule 55 (check_type -> .)
    SEMICOL         reduce using rule 55 (check_type -> .)

    check_type                     shift and go to state 82

state 125

    (49) value -> CTE_F .

    COMMA           reduce using rule 49 (value -> CTE_F .)
    SEMICOL         reduce using rule 49 (value -> CTE_F .)


state 126

    (50) value -> CTE_I .

    COMMA           reduce using rule 50 (value -> CTE_I .)
    SEMICOL         reduce using rule 50 (value -> CTE_I .)


state 127

    (43) vars3G -> ID . COMMA vars3G
    (44) vars3G -> ID . SEMICOL varsG
    (45) vars3G -> ID . SEMICOL

    COMMA           shift and go to state 93
    SEMICOL         shift and go to state 142


state 128

    (57) funcion -> tipo ID LP param RP LB statement . RB funcion
    (59) funcion -> tipo ID LP param RP LB statement . RB

    RB              shift and go to state 143


state 129

    (13) main -> tipo MAIN LP RP LB statement RB .

    $end            reduce using rule 13 (main -> tipo MAIN LP RP LB statement RB .)
    VOID            reduce using rule 13 (main -> tipo MAIN LP RP LB statement RB .)
    INT             reduce using rule 13 (main -> tipo MAIN LP RP LB statement RB .)
    FLOAT           reduce using rule 13 (main -> tipo MAIN LP RP LB statement RB .)
    CHAR            reduce using rule 13 (main -> tipo MAIN LP RP LB statement RB .)


state 130

    (15) statement -> asignacion SEMICOL . statement
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    asignacion                     shift and go to state 96
    statement                      shift and go to state 144
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 131

    (16) statement -> if statement .

    RB              reduce using rule 16 (statement -> if statement .)


state 132

    (17) statement -> vars statement .

    RB              reduce using rule 17 (statement -> vars statement .)


state 133

    (19) asignacion -> ID IS . value
    (49) value -> . CTE_F
    (50) value -> . CTE_I
    (51) value -> . ID
    (52) value -> . CTE_C
    (53) value -> . COMILLA ID COMILLA
    (54) value -> . COMILLAS ID COMILLAS

    CTE_F           shift and go to state 125
    CTE_I           shift and go to state 126
    ID              shift and go to state 123
    CTE_C           shift and go to state 66
    COMILLA         shift and go to state 67
    COMILLAS        shift and go to state 68

    value                          shift and go to state 145

state 134

    (80) if -> IF LP . expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> IF LP . expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> IF LP . expression RP check_bool gotof LB statement RB guarda_salto else
    (87) expression -> . var_gt
    (88) expression -> . var_lt
    (89) expression -> . var_equal
    (90) expression -> . var_neq
    (91) expression -> . var_geq
    (92) expression -> . var_leq
    (93) expression -> . expr
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . ID
    (62) var_gt -> . expr GT expr
    (61) var_lt -> . expr LT expr
    (65) var_equal -> . expr EQUAL expr
    (66) var_neq -> . expr NEQ expr
    (64) var_geq -> . expr GEQ expr
    (63) var_leq -> . expr LEQ expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    TRUE            shift and go to state 154
    FALSE           shift and go to state 155
    ID              shift and go to state 156
    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107

    expression                     shift and go to state 146
    var_gt                         shift and go to state 147
    var_lt                         shift and go to state 148
    var_equal                      shift and go to state 149
    var_neq                        shift and go to state 150
    var_geq                        shift and go to state 151
    var_leq                        shift and go to state 152
    expr                           shift and go to state 153

state 135

    (56) funcion -> VOID ID LP param RP LB statement . RB funcion
    (58) funcion -> VOID ID LP param RP LB statement . RB

    RB              shift and go to state 157


state 136

    (14) main -> VOID tipo MAIN LP RP LB statement . RB

    RB              shift and go to state 158


state 137

    (77) row -> LC expr RC .

    LC              reduce using rule 77 (row -> LC expr RC .)
    SEMICOL         reduce using rule 77 (row -> LC expr RC .)
    MUL             reduce using rule 77 (row -> LC expr RC .)
    DIV             reduce using rule 77 (row -> LC expr RC .)
    PLUS            reduce using rule 77 (row -> LC expr RC .)
    MINUS           reduce using rule 77 (row -> LC expr RC .)
    RC              reduce using rule 77 (row -> LC expr RC .)
    GT              reduce using rule 77 (row -> LC expr RC .)
    LT              reduce using rule 77 (row -> LC expr RC .)
    EQUAL           reduce using rule 77 (row -> LC expr RC .)
    NEQ             reduce using rule 77 (row -> LC expr RC .)
    GEQ             reduce using rule 77 (row -> LC expr RC .)
    LEQ             reduce using rule 77 (row -> LC expr RC .)
    RP              reduce using rule 77 (row -> LC expr RC .)


state 138

    (28) vars2 -> ID IS . value COMMA vars2
    (29) vars2 -> ID IS . value COMMA
    (30) vars2 -> ID IS . value SEMICOL vars
    (49) value -> . CTE_F
    (50) value -> . CTE_I
    (51) value -> . ID
    (52) value -> . CTE_C
    (53) value -> . COMILLA ID COMILLA
    (54) value -> . COMILLAS ID COMILLAS

    CTE_F           shift and go to state 125
    CTE_I           shift and go to state 126
    ID              shift and go to state 123
    CTE_C           shift and go to state 66
    COMILLA         shift and go to state 67
    COMILLAS        shift and go to state 68

    value                          shift and go to state 159

state 139

    (40) vars2G -> ID . IS value check_type COMMA vars2G
    (41) vars2G -> ID . IS value check_type SEMICOL varsG

    IS              shift and go to state 92


state 140

    (40) vars2G -> ID IS value check_type COMMA vars2G .

    VOID            reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    INT             reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    FLOAT           reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    CHAR            reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    $end            reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    ID              reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    IF              reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    VAR             reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)
    RB              reduce using rule 40 (vars2G -> ID IS value check_type COMMA vars2G .)


state 141

    (41) vars2G -> ID IS value check_type SEMICOL varsG .

    VOID            reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    INT             reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    FLOAT           reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    CHAR            reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    $end            reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    ID              reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    IF              reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    VAR             reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)
    RB              reduce using rule 41 (vars2G -> ID IS value check_type SEMICOL varsG .)


state 142

    (44) vars3G -> ID SEMICOL . varsG
    (45) vars3G -> ID SEMICOL .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for VAR resolved as shift
    RB              reduce using rule 45 (vars3G -> ID SEMICOL .)
    VOID            reduce using rule 45 (vars3G -> ID SEMICOL .)
    INT             reduce using rule 45 (vars3G -> ID SEMICOL .)
    FLOAT           reduce using rule 45 (vars3G -> ID SEMICOL .)
    CHAR            reduce using rule 45 (vars3G -> ID SEMICOL .)
    $end            reduce using rule 45 (vars3G -> ID SEMICOL .)
    ID              reduce using rule 45 (vars3G -> ID SEMICOL .)
    IF              reduce using rule 45 (vars3G -> ID SEMICOL .)
    VAR             shift and go to state 42

  ! VAR             [ reduce using rule 45 (vars3G -> ID SEMICOL .) ]

    varsG                          shift and go to state 160

state 143

    (57) funcion -> tipo ID LP param RP LB statement RB . funcion
    (59) funcion -> tipo ID LP param RP LB statement RB .
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    $end            reduce using rule 59 (funcion -> tipo ID LP param RP LB statement RB .)
    VOID            shift and go to state 30
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! VOID            [ reduce using rule 59 (funcion -> tipo ID LP param RP LB statement RB .) ]
  ! INT             [ reduce using rule 59 (funcion -> tipo ID LP param RP LB statement RB .) ]
  ! FLOAT           [ reduce using rule 59 (funcion -> tipo ID LP param RP LB statement RB .) ]
  ! CHAR            [ reduce using rule 59 (funcion -> tipo ID LP param RP LB statement RB .) ]

    tipo                           shift and go to state 31
    funcion                        shift and go to state 161

state 144

    (15) statement -> asignacion SEMICOL statement .

    RB              reduce using rule 15 (statement -> asignacion SEMICOL statement .)


state 145

    (19) asignacion -> ID IS value .

    SEMICOL         reduce using rule 19 (asignacion -> ID IS value .)


state 146

    (80) if -> IF LP expression . RP check_bool gotof LB statement RB guarda_salto
    (81) if -> IF LP expression . RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> IF LP expression . RP check_bool gotof LB statement RB guarda_salto else

    RP              shift and go to state 162


state 147

    (87) expression -> var_gt .

    RP              reduce using rule 87 (expression -> var_gt .)


state 148

    (88) expression -> var_lt .

    RP              reduce using rule 88 (expression -> var_lt .)


state 149

    (89) expression -> var_equal .

    RP              reduce using rule 89 (expression -> var_equal .)


state 150

    (90) expression -> var_neq .

    RP              reduce using rule 90 (expression -> var_neq .)


state 151

    (91) expression -> var_geq .

    RP              reduce using rule 91 (expression -> var_geq .)


state 152

    (92) expression -> var_leq .

    RP              reduce using rule 92 (expression -> var_leq .)


state 153

    (93) expression -> expr .
    (62) var_gt -> expr . GT expr
    (61) var_lt -> expr . LT expr
    (65) var_equal -> expr . EQUAL expr
    (66) var_neq -> expr . NEQ expr
    (64) var_geq -> expr . GEQ expr
    (63) var_leq -> expr . LEQ expr
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 93 (expression -> expr .)
    GT              shift and go to state 163
    LT              shift and go to state 164
    EQUAL           shift and go to state 165
    NEQ             shift and go to state 166
    GEQ             shift and go to state 167
    LEQ             shift and go to state 168
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 154

    (94) expression -> TRUE .

    RP              reduce using rule 94 (expression -> TRUE .)


state 155

    (95) expression -> FALSE .

    RP              reduce using rule 95 (expression -> FALSE .)


state 156

    (96) expression -> ID .
    (74) expr -> ID .
    (75) expr -> ID . row
    (76) expr -> ID . matrix
    (77) row -> . LC expr RC
    (78) matrix -> . row row

  ! reduce/reduce conflict for RP resolved using rule 74 (expr -> ID .)
    GT              reduce using rule 74 (expr -> ID .)
    LT              reduce using rule 74 (expr -> ID .)
    EQUAL           reduce using rule 74 (expr -> ID .)
    NEQ             reduce using rule 74 (expr -> ID .)
    GEQ             reduce using rule 74 (expr -> ID .)
    LEQ             reduce using rule 74 (expr -> ID .)
    MUL             reduce using rule 74 (expr -> ID .)
    DIV             reduce using rule 74 (expr -> ID .)
    PLUS            reduce using rule 74 (expr -> ID .)
    MINUS           reduce using rule 74 (expr -> ID .)
    RP              reduce using rule 74 (expr -> ID .)
    LC              shift and go to state 79

  ! RP              [ reduce using rule 96 (expression -> ID .) ]

    row                            shift and go to state 77
    matrix                         shift and go to state 78

state 157

    (56) funcion -> VOID ID LP param RP LB statement RB . funcion
    (58) funcion -> VOID ID LP param RP LB statement RB .
    (56) funcion -> . VOID ID LP param RP LB statement RB funcion
    (57) funcion -> . tipo ID LP param RP LB statement RB funcion
    (58) funcion -> . VOID ID LP param RP LB statement RB
    (59) funcion -> . tipo ID LP param RP LB statement RB
    (46) tipo -> . INT
    (47) tipo -> . FLOAT
    (48) tipo -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    $end            reduce using rule 58 (funcion -> VOID ID LP param RP LB statement RB .)
    VOID            shift and go to state 30
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! VOID            [ reduce using rule 58 (funcion -> VOID ID LP param RP LB statement RB .) ]
  ! INT             [ reduce using rule 58 (funcion -> VOID ID LP param RP LB statement RB .) ]
  ! FLOAT           [ reduce using rule 58 (funcion -> VOID ID LP param RP LB statement RB .) ]
  ! CHAR            [ reduce using rule 58 (funcion -> VOID ID LP param RP LB statement RB .) ]

    funcion                        shift and go to state 169
    tipo                           shift and go to state 31

state 158

    (14) main -> VOID tipo MAIN LP RP LB statement RB .

    $end            reduce using rule 14 (main -> VOID tipo MAIN LP RP LB statement RB .)
    VOID            reduce using rule 14 (main -> VOID tipo MAIN LP RP LB statement RB .)
    INT             reduce using rule 14 (main -> VOID tipo MAIN LP RP LB statement RB .)
    FLOAT           reduce using rule 14 (main -> VOID tipo MAIN LP RP LB statement RB .)
    CHAR            reduce using rule 14 (main -> VOID tipo MAIN LP RP LB statement RB .)


state 159

    (28) vars2 -> ID IS value . COMMA vars2
    (29) vars2 -> ID IS value . COMMA
    (30) vars2 -> ID IS value . SEMICOL vars

    COMMA           shift and go to state 80
    SEMICOL         shift and go to state 81


state 160

    (44) vars3G -> ID SEMICOL varsG .

    RB              reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    VOID            reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    INT             reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    FLOAT           reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    CHAR            reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    $end            reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    ID              reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    IF              reduce using rule 44 (vars3G -> ID SEMICOL varsG .)
    VAR             reduce using rule 44 (vars3G -> ID SEMICOL varsG .)


state 161

    (57) funcion -> tipo ID LP param RP LB statement RB funcion .

    VOID            reduce using rule 57 (funcion -> tipo ID LP param RP LB statement RB funcion .)
    INT             reduce using rule 57 (funcion -> tipo ID LP param RP LB statement RB funcion .)
    FLOAT           reduce using rule 57 (funcion -> tipo ID LP param RP LB statement RB funcion .)
    CHAR            reduce using rule 57 (funcion -> tipo ID LP param RP LB statement RB funcion .)
    $end            reduce using rule 57 (funcion -> tipo ID LP param RP LB statement RB funcion .)


state 162

    (80) if -> IF LP expression RP . check_bool gotof LB statement RB guarda_salto
    (81) if -> IF LP expression RP . check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> IF LP expression RP . check_bool gotof LB statement RB guarda_salto else
    (97) check_bool -> .

    LB              reduce using rule 97 (check_bool -> .)

    check_bool                     shift and go to state 170

state 163

    (62) var_gt -> expr GT . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 171

state 164

    (61) var_lt -> expr LT . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 172

state 165

    (65) var_equal -> expr EQUAL . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 173

state 166

    (66) var_neq -> expr NEQ . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 174

state 167

    (64) var_geq -> expr GEQ . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 175

state 168

    (63) var_leq -> expr LEQ . expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107
    ID              shift and go to state 108

    expr                           shift and go to state 176

state 169

    (56) funcion -> VOID ID LP param RP LB statement RB funcion .

    VOID            reduce using rule 56 (funcion -> VOID ID LP param RP LB statement RB funcion .)
    INT             reduce using rule 56 (funcion -> VOID ID LP param RP LB statement RB funcion .)
    FLOAT           reduce using rule 56 (funcion -> VOID ID LP param RP LB statement RB funcion .)
    CHAR            reduce using rule 56 (funcion -> VOID ID LP param RP LB statement RB funcion .)
    $end            reduce using rule 56 (funcion -> VOID ID LP param RP LB statement RB funcion .)


state 170

    (80) if -> IF LP expression RP check_bool . gotof LB statement RB guarda_salto
    (81) if -> IF LP expression RP check_bool . gotof LB statement RB guarda_salto elseif
    (82) if -> IF LP expression RP check_bool . gotof LB statement RB guarda_salto else
    (98) gotof -> .

    LB              reduce using rule 98 (gotof -> .)

    gotof                          shift and go to state 177

state 171

    (62) var_gt -> expr GT expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 62 (var_gt -> expr GT expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 172

    (61) var_lt -> expr LT expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 61 (var_lt -> expr LT expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 173

    (65) var_equal -> expr EQUAL expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 65 (var_equal -> expr EQUAL expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 174

    (66) var_neq -> expr NEQ expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 66 (var_neq -> expr NEQ expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 175

    (64) var_geq -> expr GEQ expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 64 (var_geq -> expr GEQ expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 176

    (63) var_leq -> expr LEQ expr .
    (68) expr -> expr . MUL expr
    (69) expr -> expr . DIV expr
    (70) expr -> expr . PLUS expr
    (71) expr -> expr . MINUS expr

    RP              reduce using rule 63 (var_leq -> expr LEQ expr .)
    MUL             shift and go to state 84
    DIV             shift and go to state 85
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 177

    (80) if -> IF LP expression RP check_bool gotof . LB statement RB guarda_salto
    (81) if -> IF LP expression RP check_bool gotof . LB statement RB guarda_salto elseif
    (82) if -> IF LP expression RP check_bool gotof . LB statement RB guarda_salto else

    LB              shift and go to state 178


state 178

    (80) if -> IF LP expression RP check_bool gotof LB . statement RB guarda_salto
    (81) if -> IF LP expression RP check_bool gotof LB . statement RB guarda_salto elseif
    (82) if -> IF LP expression RP check_bool gotof LB . statement RB guarda_salto else
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 179
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 179

    (80) if -> IF LP expression RP check_bool gotof LB statement . RB guarda_salto
    (81) if -> IF LP expression RP check_bool gotof LB statement . RB guarda_salto elseif
    (82) if -> IF LP expression RP check_bool gotof LB statement . RB guarda_salto else

    RB              shift and go to state 180


state 180

    (80) if -> IF LP expression RP check_bool gotof LB statement RB . guarda_salto
    (81) if -> IF LP expression RP check_bool gotof LB statement RB . guarda_salto elseif
    (82) if -> IF LP expression RP check_bool gotof LB statement RB . guarda_salto else
    (99) guarda_salto -> .

    ELSEIF          reduce using rule 99 (guarda_salto -> .)
    ELSE            reduce using rule 99 (guarda_salto -> .)
    ID              reduce using rule 99 (guarda_salto -> .)
    IF              reduce using rule 99 (guarda_salto -> .)
    VAR             reduce using rule 99 (guarda_salto -> .)
    RB              reduce using rule 99 (guarda_salto -> .)

    guarda_salto                   shift and go to state 181

state 181

    (80) if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto .
    (81) if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto . elseif
    (82) if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto . else
    (83) elseif -> . ELSEIF LP expression RP check_bool LB statement RB guarda_salto
    (84) elseif -> . ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif
    (85) elseif -> . ELSEIF LP expression RP check_bool LB statement RB guarda_salto else
    (86) else -> . ELSE LB statement RB guarda_salto

    ID              reduce using rule 80 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto .)
    IF              reduce using rule 80 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto .)
    VAR             reduce using rule 80 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto .)
    RB              reduce using rule 80 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto .)
    ELSEIF          shift and go to state 184
    ELSE            shift and go to state 185

    elseif                         shift and go to state 182
    else                           shift and go to state 183

state 182

    (81) if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif .

    ID              reduce using rule 81 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif .)
    IF              reduce using rule 81 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif .)
    VAR             reduce using rule 81 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif .)
    RB              reduce using rule 81 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif .)


state 183

    (82) if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto else .

    ID              reduce using rule 82 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto else .)
    IF              reduce using rule 82 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto else .)
    VAR             reduce using rule 82 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto else .)
    RB              reduce using rule 82 (if -> IF LP expression RP check_bool gotof LB statement RB guarda_salto else .)


state 184

    (83) elseif -> ELSEIF . LP expression RP check_bool LB statement RB guarda_salto
    (84) elseif -> ELSEIF . LP expression RP check_bool LB statement RB guarda_salto elseif
    (85) elseif -> ELSEIF . LP expression RP check_bool LB statement RB guarda_salto else

    LP              shift and go to state 186


state 185

    (86) else -> ELSE . LB statement RB guarda_salto

    LB              shift and go to state 187


state 186

    (83) elseif -> ELSEIF LP . expression RP check_bool LB statement RB guarda_salto
    (84) elseif -> ELSEIF LP . expression RP check_bool LB statement RB guarda_salto elseif
    (85) elseif -> ELSEIF LP . expression RP check_bool LB statement RB guarda_salto else
    (87) expression -> . var_gt
    (88) expression -> . var_lt
    (89) expression -> . var_equal
    (90) expression -> . var_neq
    (91) expression -> . var_geq
    (92) expression -> . var_leq
    (93) expression -> . expr
    (94) expression -> . TRUE
    (95) expression -> . FALSE
    (96) expression -> . ID
    (62) var_gt -> . expr GT expr
    (61) var_lt -> . expr LT expr
    (65) var_equal -> . expr EQUAL expr
    (66) var_neq -> . expr NEQ expr
    (64) var_geq -> . expr GEQ expr
    (63) var_leq -> . expr LEQ expr
    (68) expr -> . expr MUL expr
    (69) expr -> . expr DIV expr
    (70) expr -> . expr PLUS expr
    (71) expr -> . expr MINUS expr
    (72) expr -> . CTE_I
    (73) expr -> . CTE_F
    (74) expr -> . ID
    (75) expr -> . ID row
    (76) expr -> . ID matrix

    TRUE            shift and go to state 154
    FALSE           shift and go to state 155
    ID              shift and go to state 156
    CTE_I           shift and go to state 106
    CTE_F           shift and go to state 107

    expression                     shift and go to state 188
    var_gt                         shift and go to state 147
    var_lt                         shift and go to state 148
    var_equal                      shift and go to state 149
    var_neq                        shift and go to state 150
    var_geq                        shift and go to state 151
    var_leq                        shift and go to state 152
    expr                           shift and go to state 153

state 187

    (86) else -> ELSE LB . statement RB guarda_salto
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 189
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 188

    (83) elseif -> ELSEIF LP expression . RP check_bool LB statement RB guarda_salto
    (84) elseif -> ELSEIF LP expression . RP check_bool LB statement RB guarda_salto elseif
    (85) elseif -> ELSEIF LP expression . RP check_bool LB statement RB guarda_salto else

    RP              shift and go to state 190


state 189

    (86) else -> ELSE LB statement . RB guarda_salto

    RB              shift and go to state 191


state 190

    (83) elseif -> ELSEIF LP expression RP . check_bool LB statement RB guarda_salto
    (84) elseif -> ELSEIF LP expression RP . check_bool LB statement RB guarda_salto elseif
    (85) elseif -> ELSEIF LP expression RP . check_bool LB statement RB guarda_salto else
    (97) check_bool -> .

    LB              reduce using rule 97 (check_bool -> .)

    check_bool                     shift and go to state 192

state 191

    (86) else -> ELSE LB statement RB . guarda_salto
    (99) guarda_salto -> .

    ID              reduce using rule 99 (guarda_salto -> .)
    IF              reduce using rule 99 (guarda_salto -> .)
    VAR             reduce using rule 99 (guarda_salto -> .)
    RB              reduce using rule 99 (guarda_salto -> .)

    guarda_salto                   shift and go to state 193

state 192

    (83) elseif -> ELSEIF LP expression RP check_bool . LB statement RB guarda_salto
    (84) elseif -> ELSEIF LP expression RP check_bool . LB statement RB guarda_salto elseif
    (85) elseif -> ELSEIF LP expression RP check_bool . LB statement RB guarda_salto else

    LB              shift and go to state 194


state 193

    (86) else -> ELSE LB statement RB guarda_salto .

    ID              reduce using rule 86 (else -> ELSE LB statement RB guarda_salto .)
    IF              reduce using rule 86 (else -> ELSE LB statement RB guarda_salto .)
    VAR             reduce using rule 86 (else -> ELSE LB statement RB guarda_salto .)
    RB              reduce using rule 86 (else -> ELSE LB statement RB guarda_salto .)


state 194

    (83) elseif -> ELSEIF LP expression RP check_bool LB . statement RB guarda_salto
    (84) elseif -> ELSEIF LP expression RP check_bool LB . statement RB guarda_salto elseif
    (85) elseif -> ELSEIF LP expression RP check_bool LB . statement RB guarda_salto else
    (15) statement -> . asignacion SEMICOL statement
    (16) statement -> . if statement
    (17) statement -> . vars statement
    (18) statement -> . empty
    (19) asignacion -> . ID IS value
    (80) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto
    (81) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto elseif
    (82) if -> . IF LP expression RP check_bool gotof LB statement RB guarda_salto else
    (20) vars -> . VAR tipo vars1
    (21) vars -> . VAR tipo vars2
    (22) vars -> . VAR tipo vars3
    (23) vars -> . VAR tipo oper_aritmetica
    (24) vars -> . varsG
    (25) vars -> . empty
    (79) empty -> .
    (34) varsG -> . VAR tipo vars1G
    (35) varsG -> . VAR tipo vars2G
    (36) varsG -> . VAR tipo vars3G
    (37) varsG -> . VAR LB varsG RB

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
    ID              shift and go to state 100
    IF              shift and go to state 101
    VAR             shift and go to state 10
    RB              reduce using rule 79 (empty -> .)

  ! ID              [ reduce using rule 79 (empty -> .) ]
  ! IF              [ reduce using rule 79 (empty -> .) ]
  ! VAR             [ reduce using rule 79 (empty -> .) ]

    statement                      shift and go to state 195
    asignacion                     shift and go to state 96
    if                             shift and go to state 97
    vars                           shift and go to state 98
    empty                          shift and go to state 99
    varsG                          shift and go to state 12

state 195

    (83) elseif -> ELSEIF LP expression RP check_bool LB statement . RB guarda_salto
    (84) elseif -> ELSEIF LP expression RP check_bool LB statement . RB guarda_salto elseif
    (85) elseif -> ELSEIF LP expression RP check_bool LB statement . RB guarda_salto else

    RB              shift and go to state 196


state 196

    (83) elseif -> ELSEIF LP expression RP check_bool LB statement RB . guarda_salto
    (84) elseif -> ELSEIF LP expression RP check_bool LB statement RB . guarda_salto elseif
    (85) elseif -> ELSEIF LP expression RP check_bool LB statement RB . guarda_salto else
    (99) guarda_salto -> .

    ELSEIF          reduce using rule 99 (guarda_salto -> .)
    ELSE            reduce using rule 99 (guarda_salto -> .)
    ID              reduce using rule 99 (guarda_salto -> .)
    IF              reduce using rule 99 (guarda_salto -> .)
    VAR             reduce using rule 99 (guarda_salto -> .)
    RB              reduce using rule 99 (guarda_salto -> .)

    guarda_salto                   shift and go to state 197

state 197

    (83) elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto .
    (84) elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto . elseif
    (85) elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto . else
    (83) elseif -> . ELSEIF LP expression RP check_bool LB statement RB guarda_salto
    (84) elseif -> . ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif
    (85) elseif -> . ELSEIF LP expression RP check_bool LB statement RB guarda_salto else
    (86) else -> . ELSE LB statement RB guarda_salto

    ID              reduce using rule 83 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto .)
    IF              reduce using rule 83 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto .)
    VAR             reduce using rule 83 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto .)
    RB              reduce using rule 83 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto .)
    ELSEIF          shift and go to state 184
    ELSE            shift and go to state 185

    elseif                         shift and go to state 198
    else                           shift and go to state 199

state 198

    (84) elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif .

    ID              reduce using rule 84 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif .)
    IF              reduce using rule 84 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif .)
    VAR             reduce using rule 84 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif .)
    RB              reduce using rule 84 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto elseif .)


state 199

    (85) elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto else .

    ID              reduce using rule 85 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto else .)
    IF              reduce using rule 85 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto else .)
    VAR             reduce using rule 85 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto else .)
    RB              reduce using rule 85 (elseif -> ELSEIF LP expression RP check_bool LB statement RB guarda_salto else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 22 resolved as shift
WARNING: shift/reduce conflict for VAR in state 49 resolved as shift
WARNING: shift/reduce conflict for VAR in state 49 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 62 resolved as shift
WARNING: shift/reduce conflict for SEMICOL in state 62 resolved as shift
WARNING: shift/reduce conflict for ID in state 74 resolved as shift
WARNING: shift/reduce conflict for IF in state 74 resolved as shift
WARNING: shift/reduce conflict for VAR in state 74 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for VAR in state 90 resolved as shift
WARNING: shift/reduce conflict for VAR in state 90 resolved as shift
WARNING: shift/reduce conflict for VAR in state 91 resolved as shift
WARNING: shift/reduce conflict for ID in state 94 resolved as shift
WARNING: shift/reduce conflict for IF in state 94 resolved as shift
WARNING: shift/reduce conflict for VAR in state 94 resolved as shift
WARNING: shift/reduce conflict for ID in state 97 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for VAR in state 97 resolved as shift
WARNING: shift/reduce conflict for ID in state 98 resolved as shift
WARNING: shift/reduce conflict for IF in state 98 resolved as shift
WARNING: shift/reduce conflict for VAR in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 102 resolved as shift
WARNING: shift/reduce conflict for IF in state 102 resolved as shift
WARNING: shift/reduce conflict for VAR in state 102 resolved as shift
WARNING: shift/reduce conflict for ID in state 103 resolved as shift
WARNING: shift/reduce conflict for IF in state 103 resolved as shift
WARNING: shift/reduce conflict for VAR in state 103 resolved as shift
WARNING: shift/reduce conflict for ID in state 112 resolved as shift
WARNING: shift/reduce conflict for ID in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 130 resolved as shift
WARNING: shift/reduce conflict for VAR in state 130 resolved as shift
WARNING: shift/reduce conflict for VAR in state 142 resolved as shift
WARNING: shift/reduce conflict for VOID in state 143 resolved as shift
WARNING: shift/reduce conflict for INT in state 143 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 143 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 143 resolved as shift
WARNING: shift/reduce conflict for VOID in state 157 resolved as shift
WARNING: shift/reduce conflict for INT in state 157 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 157 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 178 resolved as shift
WARNING: shift/reduce conflict for IF in state 178 resolved as shift
WARNING: shift/reduce conflict for VAR in state 178 resolved as shift
WARNING: shift/reduce conflict for ID in state 187 resolved as shift
WARNING: shift/reduce conflict for IF in state 187 resolved as shift
WARNING: shift/reduce conflict for VAR in state 187 resolved as shift
WARNING: shift/reduce conflict for ID in state 194 resolved as shift
WARNING: shift/reduce conflict for IF in state 194 resolved as shift
WARNING: shift/reduce conflict for VAR in state 194 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (programa1 -> empty)
WARNING: rejected rule (vars -> empty) in state 9
WARNING: reduce/reduce conflict in state 49 resolved using rule (vars1 -> ID SEMICOL)
WARNING: rejected rule (vars3 -> ID SEMICOL) in state 49
WARNING: reduce/reduce conflict in state 49 resolved using rule (vars1 -> ID SEMICOL)
WARNING: rejected rule (vars1G -> ID SEMICOL) in state 49
WARNING: reduce/reduce conflict in state 49 resolved using rule (vars1 -> ID SEMICOL)
WARNING: rejected rule (vars3G -> ID SEMICOL) in state 49
WARNING: reduce/reduce conflict in state 49 resolved using rule (vars1 -> ID SEMICOL)
WARNING: rejected rule (empty -> <empty>) in state 49
WARNING: reduce/reduce conflict in state 58 resolved using rule (vars1 -> ID SEMICOL vars)
WARNING: rejected rule (vars3 -> ID SEMICOL vars) in state 58
WARNING: reduce/reduce conflict in state 59 resolved using rule (vars1G -> ID SEMICOL varsG)
WARNING: rejected rule (vars3G -> ID SEMICOL varsG) in state 59
WARNING: reduce/reduce conflict in state 59 resolved using rule (vars -> varsG)
WARNING: rejected rule (vars1G -> ID SEMICOL varsG) in state 59
WARNING: reduce/reduce conflict in state 61 resolved using rule (value -> ID)
WARNING: rejected rule (expr -> ID) in state 61
WARNING: reduce/reduce conflict in state 64 resolved using rule (value -> CTE_F)
WARNING: rejected rule (expr -> CTE_F) in state 64
WARNING: reduce/reduce conflict in state 65 resolved using rule (value -> CTE_I)
WARNING: rejected rule (expr -> CTE_I) in state 65
WARNING: reduce/reduce conflict in state 90 resolved using rule (vars3 -> ID SEMICOL)
WARNING: rejected rule (vars3G -> ID SEMICOL) in state 90
WARNING: reduce/reduce conflict in state 90 resolved using rule (vars3 -> ID SEMICOL)
WARNING: rejected rule (empty -> <empty>) in state 90
WARNING: reduce/reduce conflict in state 91 resolved using rule (vars1G -> ID SEMICOL)
WARNING: rejected rule (vars3G -> ID SEMICOL) in state 91
WARNING: reduce/reduce conflict in state 99 resolved using rule (statement -> empty)
WARNING: rejected rule (vars -> empty) in state 99
WARNING: reduce/reduce conflict in state 121 resolved using rule (vars -> varsG)
WARNING: rejected rule (vars3G -> ID SEMICOL varsG) in state 121
WARNING: reduce/reduce conflict in state 122 resolved using rule (vars1G -> ID SEMICOL varsG)
WARNING: rejected rule (vars3G -> ID SEMICOL varsG) in state 122
WARNING: reduce/reduce conflict in state 156 resolved using rule (expr -> ID)
WARNING: rejected rule (expression -> ID) in state 156
WARNING: Rule (expression -> ID) is never reduced
